<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>可降水量とアメダス風</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 8px 12px;
      z-index: 1000;
      border-radius: 5px;
      font-family: sans-serif;
    }
    #map {
      height: 95vh;
    }
    #selectedTime {
      margin-top: 6px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="datetime">時刻選択:</label>
    <select id="datetime"></select>
    <div id="selectedTime"></div>
  </div>
  <div id="map"></div>

  <script>
    const proxy = "https://api.allorigins.win/raw?url=";
    const stationURL =
      proxy + encodeURIComponent("https://web.lhtc-pwv.com/web/pwv.station.csv");

    // Leaflet地図初期化
    const map = L.map("map").setView([35.8, 139.8], 9);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap contributors",
    }).addTo(map);

    // PWVと風のレイヤーグループ
    let pwvLayerGroup = L.layerGroup().addTo(map);
    let windLayerGroup = L.layerGroup().addTo(map);

    // PWVの色分け関数
    function getColor(pwv) {
      return pwv > 50
        ? "#800026"
        : pwv > 40
        ? "#BD0026"
        : pwv > 30
        ? "#E31A1C"
        : pwv > 25
        ? "#FC4E2A"
        : pwv > 20
        ? "#FD8D3C"
        : pwv > 15
        ? "#FEB24C"
        : pwv > 10
        ? "#FED976"
        : "#FFEDA0";
    }

    // 現在UTC時刻から10分引いて、その時刻を1時間単位で丸める関数
    function getRoundedHourUTC() {
      const now = new Date();
      // UTC時刻に変換
      const utc = new Date(
        now.getTime()
      );
      // 40分引く
      utc.setUTCMinutes(utc.getUTCMinutes() - 40);
      // 正時に丸める
      utc.setUTCMinutes(0, 0, 0);
      return utc;
    }

    // 日時セレクトボックスに過去7日分（168時間分）をUTC基準でセットし、JST表示
    function populateDatetimeSelect() {
      const select = document.getElementById("datetime");
      const baseUTC = getRoundedHourUTC();

      for (let i = 0; i <= 192; i++) {
        const dtUTC = new Date(baseUTC.getTime() - i * 3600000);
        const utcStr = formatDatetimeJMA(dtUTC); // YYYYMMDDHH00 (UTC時刻API用)

        // JST表示用にUTC+9時間に変換
        const dtJST = new Date(dtUTC.getTime());
        const label = `${dtJST.getFullYear()}-${String(dtJST.getMonth() + 1).padStart(
          2,
          "0"
        )}-${String(dtJST.getDate()).padStart(2, "0")} ${String(dtJST.getHours()).padStart(
          2,
          "0"
        )}:00 JST`;

        const option = document.createElement("option");
        option.value = utcStr;
        option.textContent = label;
        if (i === 0) option.selected = true;
        select.appendChild(option);
      }
    }

    // YYYYMMDDHH00 フォーマット作成 (UTC時刻をJMA用に)
    function formatDatetimeJMA(date) {
      const y = date.getUTCFullYear();
      const m = String(date.getUTCMonth() + 1).padStart(2, "0");
      const d = String(date.getUTCDate()).padStart(2, "0");
      const h = String(date.getUTCHours()).padStart(2, "0");
      return `${y}${m}${d}${h}00`;
    }

async function loadPWV(datetimeStr) {
  pwvLayerGroup.clearLayers();

  const ymd = datetimeStr.substring(0, 8);
  const h = datetimeStr.substring(8, 10);

  const pwvURL =
    proxy +
    encodeURIComponent(`https://web.lhtc-pwv.com/web/${ymd}/pwvweb.${datetimeStr}.csv`);

  try {
    const [stationRes, pwvRes] = await Promise.all([fetch(stationURL), fetch(pwvURL)]);
    if (!stationRes.ok || !pwvRes.ok) {
      throw new Error("PWVデータ取得失敗");
    }

    const stationText = await stationRes.text();
    const pwvText = await pwvRes.text();

    const stationData = {};
    stationText.trim().split("\n").forEach((line) => {
      const [id, lat, lon, alt] = line.split(",");
      stationData[id] = {
        lat: parseFloat(lat),
        lon: parseFloat(lon),
        alt: parseFloat(alt),
      };
    });

    // --- PWV値の集計（同じIDが複数行あっても平均を取る）---
    const pwvValuesById = {};

    pwvText.trim().split("\n").forEach((line) => {
      const [id, pwvStr] = line.split(",");
      const pwv = parseFloat(pwvStr);
      if (!isNaN(pwv)) {
        if (!pwvValuesById[id]) {
          pwvValuesById[id] = [];
        }
        pwvValuesById[id].push(pwv);
      }
    });

    Object.entries(pwvValuesById).forEach(([id, pwvList]) => {
      const info = stationData[id];
      if (!info || pwvList.length === 0) return;

      const avgPWV = pwvList.reduce((sum, val) => sum + val, 0) / pwvList.length;
      const roundedPWV = Math.round(avgPWV);

      const color = getColor(avgPWV);
      const circle = L.circleMarker([info.lat, info.lon], {
        radius: 8,
        color: color,
        fillColor: color,
        fillOpacity: 0.6,
        weight: 1,
      });
      circle.addTo(pwvLayerGroup);

      const label = L.divIcon({
        className: "pwv-label",
        html: `<div style="color:black; font-size:12px; font-weight:bold;">${roundedPWV}</div>`,
        iconSize: [30, 12],
        iconAnchor: [15, 6],
      });
      const marker = L.marker([info.lat, info.lon], { icon: label });
      marker.addTo(pwvLayerGroup);
    });
  } catch (err) {
    console.error(err);
  }
}

let amedasLocData = null;  // 緯度経度情報

async function loadAmedasLocData() {
  const url = "https://www.jma.go.jp/bosai/amedas/const/amedastable.json";
  const res = await fetch(url);
  if (!res.ok) throw new Error("アメダス地点データ取得失敗");
  amedasLocData = await res.json();
}

function drawWindArrowWithSpeed(lat, lon, windDir, windSpeed) {
  // 風向は「風が吹いてくる方向」→矢印は逆向きに
  const arrowDir = (windDir + 180) % 360;
  const rad = (arrowDir * Math.PI) / 180;

  // 矢印の長さ（緯度経度差で適当に調整）
  const length = 0.1; // 地図のズームに応じて調整してください

  // 矢印の開始点（地図上の地点）
  const startLat = lat;
  const startLon = lon;

  // 終点計算
  const endLat = startLat + length * windSpeed / 4.0 * Math.cos(rad);
  const endLon = startLon + length * windSpeed / 4.0 * Math.sin(rad);

  // 矢印本体（線）
  const line = L.polyline([[startLat, startLon], [endLat, endLon]], {
    color: "blue",
    weight: 2,
    opacity: 0.9,
  }).addTo(windLayerGroup);

  // 矢印の頭（三角形）を作成するための点を計算
  const headLength = 0.03; // 矢印頭の大きさ
  const headAngle = 20 * (Math.PI / 180); // 矢印頭の開き角度

  // 矢印の先端点
  const tipLat = endLat;
  const tipLon = endLon;

  // 左右の矢印頭の点を計算
  const leftLat = tipLat - headLength * windSpeed / 4.0 * Math.cos(rad - headAngle);
  const leftLon = tipLon - headLength * windSpeed / 4.0 * Math.sin(rad - headAngle);

  const rightLat = tipLat - headLength * windSpeed / 4.0 * Math.cos(rad + headAngle);
  const rightLon = tipLon - headLength * windSpeed / 4.0 * Math.sin(rad + headAngle);

  // 矢印頭（三角形）をポリラインで作成（閉じる）
  const arrowHead = L.polygon(
    [
      [tipLat, tipLon],
      [leftLat, leftLon],
      [rightLat, rightLon],
    ],
    { color: "blue", fillColor: "blue", fillOpacity: 0.9 }
  ).addTo(windLayerGroup);
}

async function loadAmedasWind(datetimeStr) {
  windLayerGroup.clearLayers();

  if (!amedasLocData) {
    await loadAmedasLocData();
  }

  // UTC文字列 → Dateオブジェクト
  const utcDate = new Date(
    Date.UTC(
      parseInt(datetimeStr.slice(0, 4), 10),
      parseInt(datetimeStr.slice(4, 6), 10) - 1,
      parseInt(datetimeStr.slice(6, 8), 10),
      parseInt(datetimeStr.slice(8, 10), 10)
    )
  );

  // JST形式に整形（JMA用）
  const y = utcDate.getFullYear();
  const m = String(utcDate.getMonth() + 1).padStart(2, "0");
  const d = String(utcDate.getDate()).padStart(2, "0");
  const h = String(utcDate.getHours()).padStart(2, "0");
  const jmaDatetimeStr = `${y}${m}${d}${h}`;

  const url = `https://www.jma.go.jp/bosai/amedas/data/map/${jmaDatetimeStr}0000.json`;

  const res = await fetch(url);
  if (!res.ok) {
    console.error("アメダス風データ取得失敗:", url);
    return;
  }
  const data = await res.json();

  Object.entries(data).forEach(([id, val]) => {
    if (!(id in amedasLocData)) return;
    const loc = amedasLocData[id];
    if (!loc.lat || !loc.lon) return;

    const lat = loc.lat[0] + loc.lat[1] / 60;
    const lon = loc.lon[0] + loc.lon[1] / 60;

    const windDir = val.windDirection?.[0] * 360 / 16.0;
    const windSpeed = val.wind?.[0];

    if (typeof windDir !== "number" || typeof windSpeed !== "number") return;

    drawWindArrowWithSpeed(lat, lon, windDir, windSpeed);
  });
}

    // 時刻変更時の更新処理
    async function updateAll() {
      const datetimeStr = document.getElementById("datetime").value;

      // JST表示も更新
      const y = parseInt(datetimeStr.slice(0, 4), 10);
      const m = parseInt(datetimeStr.slice(4, 6), 10);
      const d = parseInt(datetimeStr.slice(6, 8), 10);
      const h = parseInt(datetimeStr.slice(8, 10), 10);

      const utcDate = new Date(Date.UTC(y, m - 1, d, h));
      const jstDate = new Date(utcDate.getTime());

      document.getElementById("selectedTime").textContent = `表示時刻: ${jstDate.getFullYear()}-${String(
        jstDate.getMonth() + 1
      ).padStart(2, "0")}-${String(jstDate.getDate()).padStart(2, "0")} ${String(
        jstDate.getHours()
      ).padStart(2, "0")}:00 JST`;

      await Promise.all([loadPWV(datetimeStr), loadAmedasWind(datetimeStr)]);
    }

    // イベント設定
    document.getElementById("datetime").addEventListener("change", updateAll);

    // 初期化
    populateDatetimeSelect();
    updateAll();
  </script>
</body>
</html>
