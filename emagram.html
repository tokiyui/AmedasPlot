<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MSM温位エマグラム</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
    }
    canvas {
      border: 1px solid #ccc;
      margin-top: 10px;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    #controls {
      margin-top: 10px;
    }
    select {
      margin: 0 10px;
    }
    #loading {
      color: red;
      font-size: 1.5em;
      margin: 10px;
    }
  </style>
</head>
<body>
  <h1>MSM温位エマグラム</h1>
  <div id="loading">読み込み中...</div>

  <div id="controls">
    <span id="initTimeText"></span>
    <a>&nbsp;</a>
    <label for="stationSelector">地点:</label>
    <select id="stationSelector"></select>
    <a>&nbsp;</a>
    <label for="timeSelector">FT=</label>
    <select id="timeSelector"></select>
    <a>&nbsp;</a>
    <span id="targetTimeText"></span>
  </div>

  <canvas id="emagramCanvas" width="1200" height="600"></canvas>

  <script>
    let chartInstance = null;
    let weatherData = null;
    const DISPLAY_MAX = 39;
    const STEP = 3;
    let currentStation = "44132";

    const stations = {
      "12442": "旭川", "14163": "札幌", "19432": "釧路", "31312": "青森", "33431": "盛岡",
      "32402": "秋田", "34392": "仙台", "41277": "宇都宮", "44132": "東京", "54232": "新潟",
      "48156": "長野", "56227": "金沢", "50331": "静岡", "51106": "名古屋", "62078": "大阪",
      "66408": "岡山", "68132": "松江", "67437": "広島", "72086": "高松", "73166": "松山",
      "82182": "福岡", "88317": "鹿児島", "91197": "那覇"
    };

    const initTimeText = document.getElementById('initTimeText');
    const timeSelector = document.getElementById('timeSelector');
    const stationSelector = document.getElementById('stationSelector');
    const targetTimeText = document.getElementById('targetTimeText');
    const loadingDiv = document.getElementById('loading');

    const initDateObj = new Date(Date.now() - 2.5 * 3600000);
    initDateObj.setUTCHours(Math.floor(initDateObj.getUTCHours() / 3) * 3, 0, 0, 0);
    const pad = (n) => n.toString().padStart(2, '0');
    const initTimeStr = `${initDateObj.getUTCFullYear()}${pad(initDateObj.getUTCMonth() + 1)}${pad(initDateObj.getUTCDate())}${pad(initDateObj.getUTCHours())}0000`;
    initTimeText.textContent = `初期値：${initDateObj.getUTCFullYear()}年${pad(initDateObj.getUTCMonth() + 1)}月${pad(initDateObj.getUTCDate())}日${pad(initDateObj.getUTCHours())}UTC`;

    for (let val = 0; val <= DISPLAY_MAX; val += STEP) {
      const option = document.createElement('option');
      option.value = val;
      option.textContent = `${val}`;
      timeSelector.appendChild(option);
    }

    for (const [code, name] of Object.entries(stations)) {
      const option = document.createElement('option');
      option.value = code;
      option.textContent = name;
      if (code === currentStation) option.selected = true;
      stationSelector.appendChild(option);
    }

    async function fetchWeatherData(stationCode) {
      const corsProxy = 'https://api.allorigins.win/raw?url=';
      const url = corsProxy + encodeURIComponent(
        `https://lab.weathermap.co.jp/GPV_point_api/v1/get.py?model=MSM&ini=${initTimeStr}&ftmax=39&amedas=${stationCode}`
      );
      const response = await fetch(url);
      return await response.json();
    }

    function calculatePotentialTemperature(tempK, pressureHpa) {
      const Rd = 287.05, Cp = 1005, P0 = 1000;
      return tempK * Math.pow(P0 / pressureHpa, Rd / Cp);
    }

    function calculateEquivalentPotentialTemperature(tempK, pressureHpa, rh) {
      const tempC = tempK - 273.15;
      const es = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5));
      const e = rh / 100 * es;
      const lnRatio = Math.log(e / 6.112);
      const Td_C = (243.5 * lnRatio) / (17.67 - lnRatio);
      const Td_K = Td_C + 273.15;
      const w = 0.622 * e / (pressureHpa - e);
      const TLCL = 1 / (1 / (Td_K - 56) + Math.log(tempK / Td_K) / 800) + 56;
      const thetaE = tempK * Math.pow(1000 / pressureHpa, 0.2854) * Math.exp(((3376 / TLCL) - 2.54) * w * (1 + 0.81 * w));
      return thetaE;
    }

    function updateTargetTimeText(ftHour) {
      const ftMillis = ftHour * 3600000;
      const targetTime = new Date(initDateObj.getTime() + ftMillis);
      const pad = (n) => n.toString().padStart(2, '0');
      targetTimeText.textContent = `対象時刻：${targetTime.getFullYear()}年${pad(targetTime.getMonth() + 1)}月${pad(targetTime.getDate())}日${pad(targetTime.getHours())}JST`;
    }

    async function plotEmagram(displayTime) {
      loadingDiv.style.display = 'block';
      const timeIndex = displayTime / 3;
      updateTargetTimeText(displayTime);

      if (!weatherData) {
        weatherData = await fetchWeatherData(currentStation);
      }

      const levels = Object.keys(weatherData)
        .filter(k => !isNaN(k) && parseInt(k) >= 300)
        .sort((a, b) => b - a);

      const thetaPoints = [], thetaEPoints = [], satuationthetaEPoints = [];
      let thetaE950 = null;
      let lfcPoint = null, elPoint = null, prevDiff = null;

      for (const level of levels) {
        const levelData = weatherData[level];
        const tempK = levelData?.TMP?.[timeIndex];
        const rh = levelData?.RH?.[timeIndex];
        const height = levelData?.HGT?.[timeIndex];
        const pressure = parseInt(level);

        if (
          typeof tempK === 'number' && !isNaN(tempK) &&
          typeof rh === 'number' && !isNaN(rh) &&
          typeof height === 'number' && !isNaN(height)
        ) {
          const theta = calculatePotentialTemperature(tempK, pressure);
          const thetaE = calculateEquivalentPotentialTemperature(tempK, pressure, rh);
          const satuationthetaE = calculateEquivalentPotentialTemperature(tempK, pressure, 100);
          if (isFinite(theta) && isFinite(thetaE) && isFinite(satuationthetaE)) {
            thetaPoints.push({ x: theta, y: height });
            thetaEPoints.push({ x: thetaE, y: height });
            satuationthetaEPoints.push({ x: satuationthetaE, y: height });

            const diff = thetaE - satuationthetaE;
            if (prevDiff !== null && diff * prevDiff < 0) {
              const x1 = thetaEPoints[thetaEPoints.length - 2].x;
              const y1 = thetaEPoints[thetaEPoints.length - 2].y;
              const x2 = thetaE;
              const y2 = height;
              const crossY = y1 + (0 - prevDiff) * (y2 - y1) / (diff - prevDiff);
              const crossX = x1 + (0 - prevDiff) * (x2 - x1) / (diff - prevDiff);
              if (!lfcPoint) lfcPoint = { x: crossX, y: crossY };
              else if (!elPoint) elPoint = { x: crossX, y: crossY };
            }
            prevDiff = diff;

            if (pressure === 950) thetaE950 = thetaE;
          }
        }
      }

      function getTemp(level) {
        return weatherData[level]?.TMP?.[timeIndex];
      }
      function getRH(level) {
        return weatherData[level]?.RH?.[timeIndex];
      }

      const T850 = getTemp("850"), T700 = getTemp("700"), T500 = getTemp("500");
      const Td = (T, rh) => {
        const tempC = T - 273.15;
        const es = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5));
        const e = rh / 100 * es;
        const lnRatio = Math.log(e / 6.112);
        return (243.5 * lnRatio) / (17.67 - lnRatio);
      };
      const Td850 = Td(T850, getRH("850"));
      const Td700 = Td(T700, getRH("700"));
      const K = (T850 - 273.15) - (T500 - 273.15) + Td850 - Td700;
      const TT = (T850 - 273.15) + (T500 - 273.15) - 2 * (T700 - 273.15);
      targetTimeText.textContent += `　K-Index=${K.toFixed(1)}  TT=${TT.toFixed(1)}`;

      const ctx = document.getElementById('emagramCanvas').getContext('2d');
      if (chartInstance) chartInstance.destroy();

      chartInstance = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [
            {
              label: '温位 (θ)',
              data: thetaPoints,
              borderColor: 'red',
              backgroundColor: 'rgba(255, 0, 0, 0.5)',
              showLine: true,
              pointRadius: 4,
              tension: 0.1
            },
            {
              label: '相当温位 (θₑ)',
              data: thetaEPoints,
              borderColor: 'blue',
              backgroundColor: 'rgba(0, 0, 255, 0.5)',
              showLine: true,
              pointRadius: 4,
              tension: 0.1
            },
            {
              label: '飽和相当温位 (θₑ*)',
              data: satuationthetaEPoints,
              borderColor: 'green',
              backgroundColor: 'rgba(0, 255, 0, 0.5)',
              showLine: true,
              pointRadius: 4,
              tension: 0.1
            },
            ...(thetaE950 ? [{
              label: 'θₑ (950hPa)',
              data: [
                { x: thetaE950, y: 0 },
                { x: thetaE950, y: 10000 }
              ],
              borderColor: 'black',
              borderWidth: 2,
              showLine: true,
              pointRadius: 0
            }] : []),
            ...(lfcPoint ? [{
              label: 'LFC',
              data: [lfcPoint],
              borderColor: 'orange',
              backgroundColor: 'orange',
              pointRadius: 6,
              showLine: false
            }] : []),
            ...(elPoint ? [{
              label: 'EL',
              data: [elPoint],
              borderColor: 'red',
              backgroundColor: 'red',
              pointRadius: 6,
              showLine: false
            }] : [])
          ]
        },
        options: {
          responsive: false,
          scales: {
            x: {
              title: { display: true, text: '温位 (K)' },
              min: 240,
              max: 400
            },
            y: {
              title: { display: true, text: '高度 (m)' },
              min: 0,
              max: 10000
            }
          }
        }
      });

      loadingDiv.style.display = 'none';
    }

    plotEmagram(0);

    timeSelector.addEventListener('change', () => {
      const displayTime = parseInt(timeSelector.value);
      plotEmagram(displayTime);
    });

    stationSelector.addEventListener('change', async () => {
      currentStation = stationSelector.value;
      weatherData = null;
      plotEmagram(parseInt(timeSelector.value));
    });

    document.addEventListener('keydown', (e) => {
      let displayTime = parseInt(timeSelector.value);
      if (e.key === 'ArrowLeft' && displayTime > 0) {
        timeSelector.value = displayTime - STEP;
        plotEmagram(displayTime - STEP);
      }
      if (e.key === 'ArrowRight' && displayTime < DISPLAY_MAX) {
        timeSelector.value = displayTime + STEP;
        plotEmagram(displayTime + STEP);
      }
    });
  </script>
</body>
</html>
